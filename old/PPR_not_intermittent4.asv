function O = PPR_not_intermittent4(F,dt,ex_n_sp,sp_ind)
% this m-file generates runs a projection pursuit regression algorithm
% assuming:
% 1) the fluorescence model is F_t = C_t + epsilon_t.  
% 2) the data in not sampled intermittently.  
% 3) calcium exponentially filters spike times
%  
% Input: 
% F:        a vector fluorescence observations
% dt:       time step size
% ex_n_sp:  expected number of spikes
% 
% Output (structure):
% ppr_n:    list of spike times inferred using the ppr algorithm
% A:        peak of calcium kernel
% tau:      time constant of calcium kernel

%% set simulation parameters
Sim.dt      = dt;                   %time step size
Sim.T       = length(F);            %# of time steps
Sim.Nsec    = Sim.T*Sim.dt;         %# of sec
Sim.tvec    = Sim.dt:Sim.dt:Sim.Nsec;%time vector

%% iterate projection pursuit method updating kernel with each iteration
kern_conv       = false;            %estimated kernel has not converged
zeroy           = zeros(1,Sim.T);   %vector of zeros for speeding things up
old_resid_se    = inf;              %init old residual square error for comparison purposes

while kern_conv == false;

    [A tau] = UpdateKernel(F,Sim,sp_ind); %update kernel

    % thrialize some stuff
    ppr_n   = zeroy;                    %estimated spike train
    kern    = A*exp(-Sim.tvec/tau);     %calcium kernel
    resid   = [F zeroy];                %residual error (padded with zeros)
    resid_se= sum(resid.^2);            %residual squared error
    Mn      = zeroy;                    %estimated spike train filtered with kernel

    sp_conv = false;
    while sp_conv == false
        % update spike train
        k_r_conv    = xcorr(kern,resid);            %find location of next inferred spike
        k_r_conv    = k_r_conv(Sim.T*2-1:-1:Sim.T); %just take the desired part of the signal
        [spt ind]   = max(k_r_conv);                %find the max
        ppr_n(ind)  = 1;                            %update the estimated spike train

        % update Mn
        new_Mn      =[zeros(1,ind-1) kern(1:end-ind+1)];%fast way to get convolved new spike with kernel
        new_resid   = resid(1:Sim.T) - new_Mn;      %update new residual
        if resid_se > sum(new_resid.^2)             %if adding a spike REDUCES residual square error
            resid(1:Sim.T)  = new_resid;            %update the estimate of the residuals
            resid_se        = sum(resid.^2);        %udate residual square error
            Mn              = Mn + new_Mn;          %update Mn
        else                                        %if adding new spike INCREASES residual square error
            sp_conv=true;                           %stop adding spikes for this kernel
            new_resid_se = resid_se;                %store best residual achieved with this kernel
        end
    end

    if old_resid_se <= new_resid_se                 %if residuals got worse
        kern_conv = true;                           %converge
    else                                            %else
        old_resid_se= new_resid_se;                 %update residual error
        O.ppr_n     = ppr_n;                        %store list of best spikes
        O.A         = A;                            %store best A
        O.tau       = tau;                          %store best tau
    end
    sp_ind = find(O.ppr_n);                         %find spike indexes using new kernel
end

end