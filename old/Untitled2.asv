function n=BarrierFilt2(F,Sim,P)
% this function solves the following optimization problem:
% n = argmin sum_t ((F_t - C_t)^2 + lambda n_t
% with constraints: n_t>0 forall t, and
% C_t = a C_{t-1} + A n_t, where a=(1-dt/tau)
% 
% the approach is called the barrier method, or log barrier method.
% essentially, we iteratively solve
% 
% n_eta = argmin sum_t ((F_t - C_t)^2 + lambda n_t -eta*log(n_t)
% 
% starting with eta at some reasonably large value, and then decreasing.
% 
% Input----
% F:    fluorescence time series
% Sim.  structure of simulation parameters including
%   FrameDur: time step size
%   T_o:# of time steps
% P.    structure of neuron parameters
%   A:  jump size
%   tau:time constant size
%   lambda:prior weight = 1/(rate*A*dt)


len = Sim.T_o;                              %# time steps
eta = 1;                                    %weight on barrier function
a   = 1 - Sim.FrameDur/P.tau_c;             %decay factor
o   = ones(len,1);                          %init a unity vector
M   = spdiags([-a*o P.A*o], -1:0,len,len);  %matrix transforming calcium into spikes, ie n=M*C
C   = o;                                    %initialize calcium guess
lam = P.lambda;                             %weight of prior = 1/(A*rate*dt)

while eta>1e-13                             
    D = C - F;                              %difference vector
    n = M*C;                                %get spike train assuming a particular C
    L = D'*D+lam*sum(n)-eta*sum(log(n));    %Likilihood function using C
    s = 1;                                  %step size
    d = 1;                                  %direction
    while s > 1e-5 && norm(d)>1e-5          %converge for this eta
        D   = C - F;
        n   = M*C;
        g   = 2*D+lam*sum(M)'-eta*M'*(n.^-1);%gradient
        H   = 2*speye(len)+2*eta*M'*spdiags(n.^-2,0,len,len)*M;%Hessian
        d   = -H\g;                         %direction to step using newton-raphson
        hit = -(M*C)./(M*d);                 %step within constraint boundaries                        
        if any(hit<0)
            s = min(1,0.99*min(hit(hit>0)));
        else
            s = 1;
        end
        L_new = L+1;
        while L_new-L>=1e-7                 %make sure newton step doesn't increase objective
            C_new   = C+s*d;
            n       = M*C_new;
            if any(n<0)
                keyboard
            end
            D       = C_new - F;
            L_new   = D'*D+lam*sum(n)-eta*sum(log(n));
            s       = s/2;                  %if step increases objective function, decrease step size
        end
        C = C_new;
        L = L_new;
        [L_new, s]
    end
    eta=eta/10                              %reduce eta
end