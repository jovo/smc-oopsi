function play_initialize
% this m-file generates some simulated data and then runs a projection
% pursuit algorithm, assuming that the kernel is known
%
% Sim:  simulation parameters
% P:    parameters of "real" neuron
% R:    "real" neuron data                  (smc_em_bern_real_exp)
% S:    simulation states for both samplers (smc_em_bern_FoBaMo)
% M:    moments for both samplers           (smc_em_bern_FoBaMo)

%% start function
clear; clc;

[Sim P] = InitializeStuff;

%% set simulation parameters
Sim.Nsec    = 1;                        %# of sec
Sim.freq    = 1;
Sim.T       = round(Sim.Nsec/Sim.dt);   %total # of steps (round deals with numerical error)
Sim.T_o     = round(Sim.T/Sim.freq);    %number of observations (round deals with numerical error)
Sim.tvec    = Sim.dt:Sim.dt:Sim.Nsec;   %time vector
Sim.M       = 0;                        %# spike history terms
Sim.StimDim = 1;                        %# stimulus dimenstions
Sim.pf      = 1;
Sim.x       = ones(Sim.StimDim,Sim.T);  %stimulus

epsilon_c   = P.sigma_c*sqrt(Sim.dt)*randn(1,Sim.T);%generate noise on calcium
P.k         = 3;
sp_thres    = exp(-exp(P.k)*Sim.dt)*Sim.Nsec;
spt         = rand(1,Sim.T)>sp_thres;   %spike in 10% of time bins
P.C_init    = 0;                        %thrial calcium
P.C_0       = 0;
% P.gamma     = P.gamma*10^1;
% P.zeta      = P.zeta*10^1;

%% generate data
R.n         = zeros(1,Sim.T);           %spike times
R.C         = P.C_init*ones(1,Sim.T);   %thrialize calcium
R.n(spt)    = 1;                        %force spikes
for t=2:Sim.T                           %update calcium
    R.C(t)  = (1-P.a)*R.C(t-1) + P.A*R.n(t) + P.a*P.C_0 + epsilon_c(t);
end
R.F         = R.C + .05*randn(1,Sim.T);
% F_mu        = P.alpha*Hill_v1(P,R.C)+P.beta;    %compute E[F_t]
% F_var       = P.gamma*Hill_v1(P,R.C)+P.zeta;    %compute V[F_t]
% R.F         = F_mu+sqrt(F_var).*randn(1,Sim.T); %add noise to observations
% R.F(R.F<0)  = eps;                              %observations must be non-negative

%% thrialize thrializer

% intialize spike finder
dF          = diff(R.F);                    %get dF
[sdF ind]   = sort(dF);                     %sort dF
sp_ind      = ind(round(Sim.T*sp_thres):end);%find top (1-sp_thres)% of spikes
thr_n       = zeros(1,Sim.T);               %extize thrial guess of where spikes are
thr_n(sp_ind) = 1;                          %make vector of 1's where spikes are


% A           = fminunc(@GetA,A);
%     function err = GetA(A)
%         temp=conv(A*exp(-Sim.tvec/tau),thr_n);
%         temp=temp(1:Sim.T);
%         err=norm((temp-R.F).^2);
%     end

% the below lines of code finds the best tau assuming that calcium decays
% exponentially but is then squashed by the saturating function
% hill_n  = 1.2;
% k_d     = 1.3;
% tau=fminunc(@(tau)norm((A*exp(-temp_tvec/tau).^hill_n)./((A*exp(-temp_tvec/tau).^hill_n)+k_d)-template)^2,1); %find time constant of template

kern_conv       = false;                                %estimated kernel has not converged
zeroy           = zeros(1,Sim.T);                       %vector of zeros for speeding things up
old_resid_se    = inf;                                  %init old residual square error for comparison purposes

%% iterate projection pursuit method updating kernel with each iteration

while kern_conv == false;


    % get least mean square filter estimate of time constant for filter
    A           = mean(dF(sp_ind));
    tau         = fminunc(@GetTau,0.1);

    % thrialize some stuff
    ppr_n   = zeroy;                    %estimated spike train
    kern    = A*exp(-Sim.tvec/tau);     %calcium kernel
    resid   = [R.F zeroy];              %residual error (padded with zeros)
    resid_se= sum(resid.^2);            %residual squared error
    Mn      = zeroy;                    %estimated spike train filtered with kernel

    sp_conv = false;
    while sp_conv == false
        % update spike train
        k_r_conv    = xcorr(kern,resid);            %find location of next inferred spike
        k_r_conv    = k_r_conv(Sim.T*2:-1:Sim.T+1); %just take the desired part of the signal
        [spt ind]   = max(k_r_conv);                %find the max

        new_sp      = zeroy;                        %the new spike vector
        new_sp(ind) = 1;                            %has a 1 only at the location of the new spike
        ppr_n(ind)  = 1;                            %update the estimated spike train

        % update Mn
        new_Mn      = conv(kern,new_sp);            %the new_Mn convolves the kernel with that spike
        new_Mn      = new_Mn(1:Sim.T);              %scale and crop
        new_resid   = resid(1:Sim.T) - new_Mn;
        if resid_se > sum(new_resid.^2)
            resid(1:Sim.T)  = new_resid;            %update the estimate of the residuals
            resid_se        = sum(resid.^2);
            Mn              = Mn + new_Mn;                  %update Mn

        else
            sp_conv=true;
            new_resid_se = resid_se;
        end
    end

    sp_ind = find(ppr_n)-1;

    if old_resid_se <= new_resid_se
        kern_conv = true;
    else
        old_resid_se = new_resid_se;
        best_ppr_n   = ppr_n;
    end
end
ppr_n = best_ppr_n;


%% generate smoothing kernel and compute errors between true and estimated
% spike trains
gauss_smooth    = exp(-((linspace(-5,5,Sim.T)/.1).^2)); %smoothing gaussian kernel
smooth_real_n   = conv2(R.n,gauss_smooth,'same');       %tru spike train smoothed

smooth_thr_n    = conv2(thr_n,gauss_smooth,'same');     %smoothed thrial spike finder
thr_errs        = (smooth_real_n-smooth_thr_n).^2;      %squared errors
thr_mean        = mean(thr_errs);                       %mean
thr_var         = var(thr_errs);                        %var

% update estimated spike train and compute error
smooth_ppr_n= conv2(ppr_n,gauss_smooth,'same');
est_errs    = (smooth_real_n-smooth_ppr_n).^2;
est_mean    = mean(est_errs);
est_var     = var(est_errs);

% [S M]       = smc_em_bern_FoBaMo_v5(Sim,R,P);   %do forward-backward and get moments
% smooth_smc_n = conv2(M.nbar,gauss_smooth,'same');       %same as above but for smc-em spike train
% smc_errs     = (smooth_real_n-smooth_smc_n).^2;
% smc_mean     = mean(smc_errs);
% smc_var      = var(smc_errs);


%% plot actual and inferred spikes and smoothed trains
figure(1), clf, nrows1=7;

% calcium
subplot(nrows1,1,1), plot(Sim.tvec, R.C), ylabel('ca'), axis('tight')

%fluorescence
subplot(nrows1,1,2), plot(Sim.tvec(Sim.freq:Sim.freq:Sim.T),R.F(Sim.freq:Sim.freq:Sim.T),'.-'), ylabel('F'), axis('tight')
subplot(nrows1,1,2), hold on, plot(Sim.tvec,Mn,'r'), hold off, axis('tight')

%dF and threshold
subplot(nrows1,1,3), hold on, plot(Sim.tvec(Sim.freq:Sim.freq:Sim.T-1),dF(Sim.freq:Sim.freq:Sim.T-1),'.-'), ylabel('dF'), axis('tight')
subplot(nrows1,1,3), plot(Sim.tvec,sdF(round(Sim.T*sp_thres)),'k'), hold off, axis('tight')

%actual and smoothed spike train
subplot(nrows1,1,4), hold on, bar(Sim.tvec,R.n), ylabel((sum(R.n))),
subplot(nrows1,1,4), plot(Sim.tvec, smooth_real_n,'r'), hold off, axis('tight')
title('tru spikes and smoothed')

%thrial guess of spike train (and smoothed)
subplot(nrows1,1,5), hold on, bar(Sim.tvec,thr_n,'k'), ylabel((sum(thr_n)))
subplot(nrows1,1,5), plot(Sim.tvec, smooth_thr_n,'r'), hold off, axis('tight')
title(['dF/F and threshold spikes and mse of smoothed = ', num2str(thr_mean), '+/-', num2str(thr_var)])

%ppr guess of spike train (and smoothed)
subplot(nrows1,1,6), hold on, bar(Sim.tvec,ppr_n,'k'), ylabel((sum(ppr_n)))
subplot(nrows1,1,6), plot(Sim.tvec, smooth_ppr_n,'r'), hold off, axis('tight')
title(['projection pursuit spikes and mse of smoothed = ', num2str(est_mean), '+/-', num2str(est_var)])

%residuals
subplot(nrows1,1,7), plot(Sim.tvec,resid(1:Sim.T)), title('residuals')

%% plot 
figure(2), clf
%real spike train and smoothed
subplot(nrows4,1,1), hold on, bar(Sim.tvec,R.n), ylabel((sum(R.n))),
subplot(nrows4,1,1), plot(Sim.tvec, smooth_real_n,'r'), hold off, axis('tight')
title('tru spikes and smoothed')

subplot(nrows4,1,1), hold on, bar(Sim.tvec,ppr_n,'k'), ylabel((sum(ppr_n)))
subplot(nrows4,1,1), plot(Sim.tvec, smooth_ppr_n,'r'), hold off, axis('tight')
title(['ppr_n spikes and mse of smoothed = ', num2str(est_mean), '+/-' num2str(est_var)])

% plot template and smoothed template
subplot(nrows4,1,3), hold on,
plot(Sim.tvec, A*exp(-Sim.tvec/tau),'g')
plot(Sim.tvec,P.A*exp(-Sim.tvec./P.tau_c),'k')
hold off, legend('est','real')


    function err = GetTau(tau)
        temp=conv(A*exp(-Sim.tvec/tau),thr_n);
        temp=temp(1:Sim.T);
        err=norm((temp-R.F).^2);
    end

end

% figure(3), clf, nrows3  = 2;    %inferred calcium and
% subplot(nrows3,1,1), hold on, plot(Sim.tvec,Mn), title('calcium') %plot spike train conv with kern
% subplot(nrows3,1,2), hold on, plot(k_r_conv), title('xcorr')    %plot xcorr of kern and resid

% %smc-em est of spike train (and smoothed)
% subplot(nrows1,1,6), hold on, bar(Sim.tvec,M.nbar,'k'), ylabel((sum(M.nbar)))
% subplot(nrows1,1,6), plot(Sim.tvec, smooth_smc_n,'r'), hold off, axis('tight')
% title(['smc-em spikes and mse of smoothed = ', num2str(smc_mean), '+/-', num2str(smc_var)])
